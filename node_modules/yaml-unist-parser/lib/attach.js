"use strict";
exports.__esModule = true;
var define_parents_1 = require("./utils/define-parents");
var get_point_text_1 = require("./utils/get-point-text");
function attachComments(root) {
    define_parents_1.defineParents(root);
    var nodeTable = createNodeTable(root);
    var restDocuments = root.children.slice();
    root.comments
        .sort(function (a, b) { return a.position.start.offset - b.position.end.offset; })
        .filter(function (comment) { return !comment._parent; })
        .forEach(function (comment) {
        while (restDocuments.length > 1 &&
            comment.position.start.line > restDocuments[0].position.end.line) {
            restDocuments.shift();
        }
        attachComment(comment, nodeTable, restDocuments[0]);
    });
}
exports.attachComments = attachComments;
function createNodeTable(root) {
    var nodeTable = Array.from(new Array(root.position.end.line), function () { return ({}); });
    for (var _i = 0, _a = root.comments; _i < _a.length; _i++) {
        var comment = _a[_i];
        nodeTable[comment.position.start.line - 1].comment = comment;
    }
    initNodeTable(nodeTable, root);
    return nodeTable;
}
function initNodeTable(nodeTable, node) {
    // empty mappingKey/mappingValue
    if (node.position.start.offset === node.position.end.offset) {
        return;
    }
    if ("leadingComments" in node) {
        var start = node.position.start;
        var leadingAttachableNode = nodeTable[start.line - 1].leadingAttachableNode;
        if (!leadingAttachableNode ||
            start.column < leadingAttachableNode.position.start.column) {
            nodeTable[start.line - 1].leadingAttachableNode = node;
        }
    }
    if ("trailingComment" in node &&
        node.position.end.column > 1 &&
        node.type !== "document" &&
        node.type !== "documentHead") {
        var end = node.position.end;
        var trailingAttachableNode = nodeTable[end.line - 1].trailingAttachableNode;
        if (!trailingAttachableNode ||
            end.column >= trailingAttachableNode.position.end.column) {
            nodeTable[end.line - 1].trailingAttachableNode = node;
        }
    }
    if (node.type !== "root" &&
        node.type !== "document" &&
        node.type !== "documentHead" &&
        node.type !== "documentBody") {
        var _a = node.position, start = _a.start, end = _a.end;
        var lines = [end.line].concat(start.line === end.line ? [] : start.line);
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            var currentEndNode = nodeTable[line - 1].trailingNode;
            if (!currentEndNode || end.column >= currentEndNode.position.end.column) {
                nodeTable[line - 1].trailingNode = node;
            }
        }
    }
    if ("children" in node) {
        node.children.forEach(function (child) {
            initNodeTable(nodeTable, child);
        });
    }
}
function attachComment(comment, nodeTable, document) {
    var commentLine = comment.position.start.line;
    var trailingAttachableNode = nodeTable[commentLine - 1].trailingAttachableNode;
    if (trailingAttachableNode) {
        // istanbul ignore next
        if (trailingAttachableNode.trailingComment) {
            throw new Error("Unexpected multiple trailing comment at " + get_point_text_1.getPointText(comment.position.start));
        }
        define_parents_1.defineParents(comment, trailingAttachableNode);
        trailingAttachableNode.trailingComment = comment;
        return;
    }
    for (var line = commentLine; line >= document.position.start.line; line--) {
        var trailingNode = nodeTable[line - 1].trailingNode;
        var currentNode = void 0;
        if (!trailingNode) {
            /**
             * a:
             *   b:
             *    #b
             *  #a
             *
             * a:
             *   b:
             *  #a
             *    #a
             */
            if (line !== commentLine && nodeTable[line - 1].comment) {
                currentNode = nodeTable[line - 1].comment._parent;
            }
            else {
                continue;
            }
        }
        else {
            currentNode = trailingNode;
        }
        while (true) {
            if (shouldOwnEndComment(currentNode, comment)) {
                define_parents_1.defineParents(comment, currentNode);
                currentNode.endComments.push(comment);
                return;
            }
            if (!currentNode._parent) {
                break;
            }
            currentNode = currentNode._parent;
        }
        break;
    }
    for (var line = commentLine + 1; line <= document.position.end.line; line++) {
        var leadingAttachableNode = nodeTable[line - 1].leadingAttachableNode;
        if (leadingAttachableNode) {
            define_parents_1.defineParents(comment, leadingAttachableNode);
            leadingAttachableNode.leadingComments.push(comment);
            return;
        }
    }
    var documentBody = document.children[1];
    define_parents_1.defineParents(comment, documentBody);
    documentBody.endComments.push(comment);
}
function shouldOwnEndComment(node, comment) {
    if (comment.position.end.offset < node.position.end.offset) {
        return false;
    }
    switch (node.type) {
        case "sequenceItem":
            return comment.position.start.column > node.position.start.column;
        case "mappingKey":
        case "mappingValue":
            return (comment.position.start.column > node._parent.position.start.column &&
                (node.children.length === 0 ||
                    (node.children.length === 1 &&
                        node.children[0].type !== "blockFolded" &&
                        node.children[0].type !== "blockLiteral" &&
                        (node.type === "mappingValue" ||
                            // explicit key
                            node.position.start.offset !==
                                node.children[0].position.start.offset))));
        default:
            return false;
    }
}
